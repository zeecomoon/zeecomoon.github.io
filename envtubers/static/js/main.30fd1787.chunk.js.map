{"version":3,"sources":["SortFilter.tsx","Twitch.tsx","Live.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["SortBy","FilterBy","twitchHeaders","Headers","Accept","ids","a","channelChunks","chunk","promises","map","request","Request","join","method","headers","fetch","then","handleFetchError","res","json","Promise","all","promise","channels","flat","streams","stream","channel","response","ok","Error","statusText","arr","size","Array","from","length","Math","ceil","v","i","slice","SortFilterBar","state","filterBy","Live","sortBy","Viewers","sortDescending","setTimeout","props","onChange","sort","liveChannels","prevProps","prevState","this","shownChannels","Followers","sortByFollowers","sortByViewers","Name","sortByChannel","Game","sortByGame","Random","array","j","floor","random","sortByRandom","SortChannels","reverse","filter","game","All","setState","className","Object","values","key","FilterButton","onClick","setFilter","type","selected","SortButton","setSort","React","Component","arrow","showArrow","b","followers","aa","viewers","display_name","localeCompare","ChannelInfo","href","url","alt","data-src","logo","replace","description","StreamInfo","streamInfo","image","preview","large","Date","now","video_banner","status","mergeWithStreams","forEach","liveChannel","_id","isLoaded","isError","observer","lozad","process","user_id","updateChannels","updateStreams","setInterval","observe","LookupChannels","catch","err","LookupLiveChannels","console","log","loadingMsg","updateShownChannels","id","App","path","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","error","message"],"mappings":"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","file":"static/js/main.30fd1787.chunk.js","sourcesContent":["import React from \"react\";\nimport { Channel } from \"./Twitch\";\n\nenum SortBy {\n  Viewers = \"Viewers\",\n  Name = \"Name\",\n  Followers = \"Followers\",\n  Game = \"Game\",\n  Random = \"Random\",\n}\n\nenum FilterBy {\n  Live = \"Live\",\n  All = \"All\",\n}\n\ntype SortButtonProps = {\n  type: SortBy;\n  selected: boolean;\n  onClick: (type: SortBy) => void;\n  sortDescending: boolean;\n};\n\ntype SortFilterProps = {\n  channels: Channel[];\n  liveChannels: Channel[];\n  onChange: (shownChannels: Channel[]) => void;\n}\n\ntype SortFilterState = {\n  filterBy: FilterBy;\n  sortBy: SortBy;\n  sortDescending: boolean;\n}\n\nexport class SortFilterBar extends React.Component<SortFilterProps, SortFilterState> {\n  state: SortFilterState = {\n    filterBy: FilterBy.Live,\n    sortBy: SortBy.Viewers,\n    sortDescending: true,\n  }\n\n  componentDidMount() {\n    setTimeout(\n      () => this.props.onChange(this.sort(this.props.channels, this.props.liveChannels))\n    , 500);\n    setTimeout(\n      () => this.props.onChange(this.sort(this.props.channels, this.props.liveChannels))\n    , 1000);\n    setTimeout(\n      () => this.props.onChange(this.sort(this.props.channels, this.props.liveChannels))\n    , 2000);\n  }\n\n  componentDidUpdate(prevProps: Readonly<SortFilterProps>, prevState: Readonly<SortFilterState>) {\n    if (prevProps.channels !== this.props.channels || prevProps.liveChannels !== this.props.liveChannels ||\n      prevState.filterBy !== this.state.filterBy || prevState.sortBy !== this.state.sortBy || prevState.sortDescending !== this.state.sortDescending) {\n        this.props.onChange(this.sort(this.props.channels, this.props.liveChannels));\n    }\n  }\n\n  sort(channels: Channel[], liveChannels: Channel[]): Channel[] {\n    let shownChannels: Channel[] = [];\n    if (this.state.filterBy === FilterBy.Live) {\n      shownChannels = liveChannels;\n    } else {\n      shownChannels = channels;\n    }\n    shownChannels = SortChannels(shownChannels, this.state.sortBy);\n    if (!this.state.sortDescending) {\n      shownChannels = shownChannels.reverse();\n    }\n    if (this.state.sortBy === SortBy.Game) {\n      shownChannels = shownChannels.filter(channel => channel.game !== \"\");\n    }\n\n    return shownChannels;\n  }\n\n  setFilter(filterBy: FilterBy) {\n    if (filterBy === FilterBy.All && this.state.filterBy !== filterBy && this.state.sortBy === SortBy.Viewers) {\n      this.setState({\n        sortBy: SortBy.Followers,\n        sortDescending: true,\n      })\n    };\n    this.setState({\n      filterBy: filterBy,\n    });\n  }\n\n  setSort(sortBy: SortBy) {\n    if (this.state.sortBy === sortBy) {\n      this.setState({\n        sortDescending: !this.state.sortDescending,\n      });\n    } else {\n      this.setState({\n        sortBy: sortBy,\n        sortDescending: sortBy !== SortBy.Name && sortBy !== SortBy.Game,\n      });\n    }\n  }\n\n  render() {\n    return (\n        <div className=\"top\">\n          <div className=\"filterBy\">\n            <div className=\"optionDescription\">Filter By</div>\n            <div className=\"optionValues\">\n              {Object.values(FilterBy).map((key) => {\n                return (\n                  <div key={key}>\n                    <FilterButton\n                      onClick={() => this.setFilter(key)}\n                      type={key}\n                      selected={this.state.filterBy === key}\n                    />\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n          <div className=\"sortBy\">\n            <div className=\"optionDescription\">Sort By&nbsp;&nbsp;</div>\n            <div className=\"sortValues\">\n              {Object.values(SortBy).map((key) => {\n                return (\n                  <div key={key}>\n                    <SortButton\n                      onClick={() => this.setSort(key)}\n                      type={key}\n                      selected={this.state.sortBy === key}\n                      sortDescending={this.state.sortDescending}\n                    />\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        </div>\n    )\n  }\n}\n\nfunction SortButton(props: SortButtonProps) {\n  const className = props.selected ? \"buttonEnabled\" : \"buttonDisabled\";\n  const arrow = props.sortDescending ? \"▼\" : \"▲\";\n  const showArrow = props.selected && props.type !== SortBy.Random;\n  return (\n    <span className=\"sortValue\">\n      <span className=\"sortButton\">\n        <button className={className} onClick={() => props.onClick(props.type)}>\n          {props.type}\n        </button>\n      </span>\n      <span className=\"sortArrow\">\n        <button onClick={() => props.onClick(props.type)}>\n          {showArrow && arrow}\n        </button>\n      </span>\n    </span>\n  );\n}\n\ntype FilterButtonProps = {\n  type: FilterBy;\n  selected: boolean;\n  onClick: (type: FilterBy) => void;\n};\n\nfunction FilterButton(props: FilterButtonProps) {\n  const className = props.selected ? \"buttonEnabled\" : \"buttonDisabled\";\n  return (\n    <button className={className} onClick={() => props.onClick(props.type)}>\n      {props.type}\n    </button>\n  );\n}\n\nfunction SortChannels(channels: Channel[], sortBy: SortBy): Channel[] {\n  switch (sortBy) {\n    case SortBy.Followers:\n      return channels.sort(sortByFollowers);\n    case SortBy.Viewers:\n      return channels.sort(sortByViewers);\n    case SortBy.Name:\n      return channels.sort(sortByChannel);\n    case SortBy.Game:\n      return channels.sort(sortByGame);\n    case SortBy.Random:\n      return sortByRandom(channels);\n  }\n}\n\nfunction sortByViewers(a: Channel, b: Channel): number {\n  if (a.stream === null && b.stream === null) {\n    return b.followers - a.followers;\n  }\n\n  let aa = a.stream !== null ? a.stream.viewers : 0;\n  let bb = b.stream !== null ? b.stream.viewers : 0;\n\n  return bb - aa;\n}\n\nfunction sortByFollowers(a: Channel, b: Channel): number {\n  return b.followers - a.followers;\n}\n\nfunction sortByChannel(a: Channel, b: Channel): number {\n  return b.display_name.localeCompare(a.display_name);\n}\n\nfunction sortByGame(a: Channel, b: Channel): number {\n  return b.game.localeCompare(a.game);\n}\n\nfunction sortByRandom<T>(array: T[]): T[] {\n  for (let i = array.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [array[i], array[j]] = [array[j], array[i]];\n  }\n\n  return array\n}","export interface StreamPreview {\n  small: string;\n  medium: string;\n  large: string;\n  template: string;\n}\n\nexport interface Channel {\n  mature: boolean;\n  status: string;\n  broadcaster_language: string;\n  broadcaster_software: string;\n  display_name: string;\n  game: string;\n  language: string;\n  _id: number;\n  name: string;\n  created_at: Date;\n  updated_at: Date;\n  partner: boolean;\n  logo: string;\n  video_banner: string;\n  profile_banner: string;\n  profile_banner_background_color: string;\n  url: string;\n  views: number;\n  followers: number;\n  broadcaster_type: string;\n  description: string;\n  private_video: boolean;\n  privacy_options_enabled: boolean;\n  stream: Stream | null; // Not actually in response\n}\n\nexport interface Stream {\n  _id: string;\n  game: string;\n  broadcast_platform: string;\n  community_id: string;\n  community_ids: string[];\n  viewers: number;\n  video_height: number;\n  average_fps: number;\n  delay: number;\n  created_at: Date;\n  is_playlist: boolean;\n  stream_type: string;\n  preview: StreamPreview;\n  channel: Channel;\n}\n\nexport interface StreamsResponse {\n  streams: Stream[];\n}\n\nexport interface ChannelsResponse {\n  channels: Channel[];\n}\n\nfunction twitchHeaders(): Headers {\n  return new Headers({\n    Accept: \"application/vnd.twitchtv.v5+json\",\n    \"Client-ID\": \"kimne78kx3ncx6brgo4mv6wki5h1ko\",\n  });\n}\n\nexport async function LookupChannels(ids: string[]): Promise<Channel[]> {\n  const channelChunks: string[][] = chunk(ids, 100);\n  const promises: Promise<ChannelsResponse>[] = channelChunks.map((chunk) => {\n    let request: Request = new Request(\n      \"https://api.twitch.tv/kraken/channels?id=\" + chunk.join(\",\"),\n      {\n        method: \"GET\",\n        headers: twitchHeaders(),\n      }\n    );\n\n    return fetch(request)\n      .then(handleFetchError)\n      .then(res => res.json());\n  });\n\n  return Promise.all(promises)\n    .then(promises => promises.map(promise => promise.channels).flat())\n}\n\nexport async function LookupLiveChannels(ids: string[]): Promise<Channel[]> {\n  const channelChunks: string[][] = chunk(ids, 100);\n  const promises: Promise<StreamsResponse>[] = channelChunks.map((chunk) => {\n    let request: Request = new Request(\n      \"https://api.twitch.tv/kraken/streams?channel=\" + chunk.join(\",\"),\n      {\n        method: \"GET\",\n        headers: twitchHeaders(),\n      }\n    );\n\n    return fetch(request)\n      .then(handleFetchError)\n      .then(res => res.json());\n  });\n\n  return Promise.all(promises)\n    .then(promises => promises.map(promise => promise.streams))\n    .then(res => res.flat())\n    .then(streams =>\n      streams.map(stream => {\n        stream.channel.stream = stream;\n        return stream.channel;\n      })\n    );\n}\n\nfunction handleFetchError(response: Response) {\n  if (!response.ok) {\n    throw Error(response.statusText);\n  }\n  return response;\n}\n\nfunction chunk<T>(arr: T[], size: number): T[][] {\n  return Array.from({ length: Math.ceil(arr.length / size) }, (v, i) =>\n    arr.slice(i * size, i * size + size)\n  );\n};\n","import React from \"react\";\nimport lozad from \"lozad\";\nimport { Channel, LookupChannels, LookupLiveChannels } from \"./Twitch\";\nimport { SortFilterBar } from \"./SortFilter\";\n\ntype LiveProps = {};\n\ntype LiveState = {\n  isLoaded: boolean;\n  isError: boolean;\n\n  channels: Channel[];\n  liveChannels: Channel[];\n  shownChannels: Channel[];\n\n  observer: lozad.Observer;\n};\ninterface Vtuber {\n  user_id: \"string\";\n}\n\ntype streamInfoT = {\n  viewers: React.ReactElement;\n  image: string;\n};\n\nclass Live extends React.Component<LiveProps, LiveState> {\n  state: LiveState = {\n    isLoaded: false,\n    isError: false,\n    channels: [],\n    liveChannels: [],\n    shownChannels: [],\n    observer: lozad(),\n  };\n\n  componentDidMount() {\n    fetch(process.env.PUBLIC_URL + \"/vtubers.json\")\n      .then((res) => res.json())\n      .then((res) => res.map((channel: Vtuber) => channel.user_id))\n      .then((ids) => {\n        this.updateChannels(ids);\n        this.updateStreams(ids);\n        setInterval(() => this.updateStreams(ids), 1000 * 60 * 10);\n      });\n  }\n\n  componentDidUpdate() {\n    this.state.observer.observe();\n  }\n\n  updateChannels(ids: string[]) {\n    LookupChannels(ids)\n      .then((channels) => {\n        this.setState(\n          {\n            channels: mergeWithStreams(channels, this.state.liveChannels),\n          }\n        );\n      })\n      .catch((err) => {\n        if (!this.state.isLoaded) {\n          this.setState(\n            {\n              isError: true,\n            }\n          );\n        }\n      });\n  }\n\n  updateStreams(ids: string[]) {\n    LookupLiveChannels(ids)\n      .then((liveChannels) => {\n        this.setState(\n          {\n            isLoaded: true,\n            liveChannels: liveChannels,\n            channels: mergeWithStreams(this.state.channels, liveChannels),\n          }\n        );\n      })\n      .catch((err) => {\n        console.log(err);\n        if (!this.state.isLoaded) {\n          this.setState(\n            {\n              isError: true,\n            }\n          );\n        }\n      });\n  }\n\n  updateShownChannels(shownChannels: Channel[]) {\n    this.setState({\n      shownChannels: shownChannels,\n    });\n  }\n\n  render() {\n    let loadingMsg: string = \"Loading your anime waifus and husbandos now...\";\n    if (this.state.isError) {\n      loadingMsg = \"Error loading data :( Try refreshing\";\n    }\n    if (!this.state.isLoaded) {\n      return (\n        <div id=\"live-channels\" className=\"col s10 m8 l6\">\n          <div className=\"live-channel card grey-text lighten-5\">\n            {loadingMsg}\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"col s12 m10 l8\">\n        <SortFilterBar\n          onChange={(channels: Channel[]) => this.updateShownChannels(channels)}\n          channels={this.state.channels}\n          liveChannels={this.state.liveChannels}\n        />\n        <div id=\"live-channels\">\n          {this.state.shownChannels.map((channel) => {\n            return (\n              <div\n                className=\"live-channel card grey-text lighten-5\"\n                key={channel._id}\n              >\n                <ChannelInfo channel={channel} />\n                <StreamInfo channel={channel} />\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\ntype ChannelProps = {\n  channel: Channel;\n};\n\nfunction ChannelInfo(props: ChannelProps) {\n  return (\n    <div className=\"streamer\">\n      <div>\n        <a href={props.channel.url}>\n          <img\n            alt=\"channel logo\"\n            className=\"lozad profile-pic circle\"\n            data-src={props.channel.logo.replace(\"300x300\", \"150x150\")}\n          />\n        </a>\n        <div>\n          <a href={props.channel.url}>{props.channel.display_name}</a>\n        </div>\n        <div>\n          <strong>{props.channel.followers}</strong> followers\n        </div>\n      </div>\n      <div className=\"description card grey darken-4\">\n        {props.channel.description.slice(0, 350)}\n      </div>\n    </div>\n  );\n}\nfunction StreamInfo(props: ChannelProps) {\n  const streamInfo: streamInfoT = getStreamInfo(props.channel);\n  return (\n    <div className=\"playing\">\n      <div className=\"previewContainer\">\n        {streamInfo.image && (\n        <span>\n         {false && <img // can't get this to look right yet\n          alt={\"Boxart for \" + props.channel.game}\n          className=\"boxart\"\n          src={\"https://static-cdn.jtvnw.net/ttv-boxart/\" + props.channel.game + \"-90x120.jpg\"}\n         />}\n         {props.channel.stream !== null && <span className=\"liveIndicator\">Live</span>}\n          <a href={props.channel.url}>\n            <img className=\"lozad\" alt=\"stream preview\" data-src={streamInfo.image} />\n          </a>\n        </span>\n        )}\n      </div>\n      <div>\n        <div className=\"streamInfo\">\n          <a\n            href={\"https://www.twitch.tv/directory/game/\" + props.channel.game}\n          >\n            {props.channel.game}\n          </a>{\" \"}\n          <div>{streamInfo.viewers}</div>\n        </div>\n        <div className=\"divider\" />\n        <div>{props.channel.status}</div>\n      </div>\n    </div>\n  );\n}\n\nfunction getStreamInfo(channel: Channel): streamInfoT {\n  let streamInfo: streamInfoT = (() => {\n    if (channel.stream) {\n      return {\n        viewers: (\n          <span>\n            <strong>{channel.stream.viewers}</strong> viewers\n          </span>\n        ),\n        image: channel.stream.preview.large + \"#\" + Date.now(),\n      };\n    } else {\n      let image = channel.video_banner;\n      if (image !== null) {\n        image = image.replace(\"1920x1080\", \"426x240\");\n      }\n      return {\n        viewers: <strong>Offline</strong>,\n        image: image,\n      };\n    }\n  })();\n\n  return streamInfo;\n}\n\nfunction mergeWithStreams(\n  channels: Channel[],\n  liveChannels: Channel[]\n): Channel[] {\n  if (channels.length === 0) {\n    return [];\n  }\n  channels.forEach((channel) => (channel.stream = null));\n  liveChannels.forEach((liveChannel) => {\n    channels.filter((channel) => channel._id === liveChannel._id)[0].stream =\n      liveChannel.stream;\n  });\n\n  return channels;\n}\n\nexport default Live;\n","import React from \"react\";\nimport { HashRouter as Router, Switch, Route } from \"react-router-dom\";\nimport \"./App.css\";\nimport Live from \"./Live\";\n\nfunction App() {\n  return (\n    <Router>\n      <div className=\"App\">\n        <nav>\n          <div id=\"nav\" className=\"nav-wrapper purple lighten-3\">\n            <div id=\"logo\" className=\"title\">\n              EN VTubers\n            </div>\n          </div>\n        </nav>\n        <div id=\"page\" className=\"row\">\n          <div className=\"col s0 m1 l2\"></div>\n          <Switch>\n            <Route path=\"/\">\n              <Live />\n            </Route>\n          </Switch>\n          <div className=\"col s0 m1 l2\"></div>\n        </div>\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}